<h2> Forms</h2>
<h4>Access Form</h4>
<p>Instead of using a numerical index, we can use the name attribute to identify a form:</p>
<h4>Form Properties and Methods</h4>
<p>The form.submit() method will submit the form automatically. Note that submitting a form using this method won’t trigger the form submit event that's covered in the next section.</p>
<h4>Hidden fields</h4>
<p>Hidden fields can be created using input fields with type='hidden' . These are not displayed by the browser, but have a 'value' attribute that can contain information that is submitted with the form. They are often used to send information such as settings or information that the user has already provided. Note that the information in these fields is in no way secret, as it’s visible in the HTML, so shouldn’t be used for sensitive data. The value of a hidden input field can be changed using JavaScript in the same was as any other input field.</p>
<h2> Object-Oriented Programming in JavaScript</h2>
<h4> Create object using constructor function</h4>
<p>The parentheses are not required when instantiating a new object using a constructor function. The following code would also achieve the same result: const redDice = new Dice;</p>
<p>The ES6 class declarations are preferable to the constructor function syntax because they are more succinct, easier to read and all code in a class definition is implicitly in strict mode, so doesn't need the 'use strict' statement. Using ES6 class declarations also avoids a number of pitfalls associated with constructor functions. For example, an error is thrown when trying to call a class constructor without using the new operator, whereas doing the same thing with a constructor function can cause a lot of problems that are hard to track down:</p>
<h4>Static methods</h4>
<p>The static keyword can be used in class declarations to create a static method. These are sometimes called class methods in other programming languages</p>
<h4>What Should the Prototype Be Used For</h4>
<p>The prototype can be used to add any new properties and methods after the class has been declared. It should be used to define any properties that will remain the same for every instance of the class. The weapon example was unsuitable because all the turtles use a different weapon (we just used it in the example above to demonstrate overwriting). They do, however, like the same food — pizza! This makes a good candidate for a prototype property, if it wasn't included in the original class declaration:</p>
<h4>Polymorphism</h4>
<p>Implement it in different ways. The Object.prototype object has a toString() method that is shared by all objects. This means every object created in JavaScript will have a toString() method. Polymorphism means that objects are able to override this method with a more specific implementation. So although every object has a toString() method, the way it’s implemented can vary between different objects. For example, calling it on an array object will return each value in a comma-separated string:</p>
<h4>Define Properties</h4>
<p>lement it in different ways. The Object.prototype object has a toString() method that is shared by all objects. This means every object created in JavaScript will have a toString() method. Polymorphism means that objects are able to override this method with a more specific implementation. So although every object has a toString() method, the way it’s implemented can vary between different objects. For example, calling it on an array object will return each value in a comma-separated string:</p>
<h2>Modular JavaScript</h2>
<p>A module is a self-contained piece of code that provides functions and methods that can then be used in other files and by other modules. This helps to keep code organized in separate, reusable files, which improves code maintainability. The code in a module should have a single purpose, and group together functions with distinct functionality. For example, you might keep any functions used for Ajax in their own module. This could then be used in any projects where Ajax was required. Keeping code modular helps to make it moreloosely coupledand interchangeable, meaning you can easily swap one module for another without affecting other parts of a project. Indeed, small single-purpose modules are the exact opposite of large monolithic libraries as they enable developers to use only the modules that are needed, avoiding any wasted code. Modules also allow a public API to be exposed, while keeping the implementation hidden away inside the module.</p>
<h4>Default Exports</h4>
<p>Default exportsrefer toa singlevariable, function or class in a module that can be imported without having to be explicitly named. The syntax for default exports is purposely easier to read because this is how modules were designed to be used.</p>